# Table of contents
- [Files and Folders](#files\and\folders)
	- [Most Important Folders](#most\important\folders)
- [Routes](#routes)
	- ==[Facades](#facades)
	- [HTTP Definition](#http\definition)
	- [Example](#example)
- [Views](#views)
- [Controllers](#controllers)
	- [Setup](#setup)
	- [Referencing route to a controller](#referencing\route\to\a\controller)
- [Migrations](#migrations)
	- [The `up()` method](#the\up\(\)\method)
- [Creating models](#creating\models)
- [Blade templates](#blade\templates)
	- [Echoing data](#echoing\data)
	- [Defining a master layout](#defining\a\master\layout)
- [Components](#components)
	- [Rendering components](#rendering\components)
	- [Casing](#casing)
	- 
---

# Files and Folders

| Folder | Description |
|---------|-------------|
|app| Holds the base code of the application|
|bootstrap| Contains all the bootstrapping scripts used for the application|
|config| Holds all the configuration files of the project|
|database| Holds all the database files|
|public| Helps in starting the Laravel project it also holds other scripts such as javascript and CSS aswell as images|
|resources| Holds all the sass files, localization files and or templates|
|routes|Contains all the definition files for routing such as `console.php`, `api.php`...|
|storage|Holds all the session files, cache, compiled templates and some miscellaneous files generated by the framework|
|test| Contains all the test cases|
|Vendor| Holds all composer depencdency files|

## Most important folders
- __Models__ are in __app/Models__
- __Controllers__ are in __app/Http/Controllers__
- __Views__ art in __resources/views__ folder
- __Migrations__ are in __database/migrations__

>Javascript files are added in the __public__ folder, if we wish to use sass or tailwind we have to go through [Laravel Mix](https://laravel.com/docs/10.x/mix#main-content)

# Routes
- Routes are the main entrance of a Laravel application.
- When we create a route, we call its controller and a specific action.
- A list of all available routes can be seen with the following command: `php artisan route:list` 

## Facades
- Facades provide a _static_ interface to classes that are available in the application's service container
- Laravel ships with multiple facades that provide access to almost all of its features. 
- They serve as _static proxies_ to underlying classes in the service container.

## HTTP Definition
- HTTP defines a set of request methods to indicate the desired action to be performed for a given resouce,
- They are sometimes reffered to as HTTP verbs.
- Each one of the them implements a different action however some common features are shared among them. A request method can be safe, ==idempotent==, or cacheable.

```php
// Display all the articles
Route::get('/articles',function(){
    ...
});
// Show the form in order to create an article
Route::get('/article/create',function(){
    ...
});
// Post/public the article
Route::post('/article/create',function(){
    ...
});
// Show the form of an article
Route::get('/article/edit/{post:id}',function($id){
    ...
});
```

# Views
Views are the files that all users will see from our app. The views are called only with the _HTTP get_ request.

```
|-resources
    |-views
        |-article
          index.blade.php
          show.blade.php
          create.blade.php  
```
```php
// Show each article by its id
Route::get('/article/show/{post:id}',function($id){
    return view('article.edit',['id' => $id]);
});
```

## Passing arguments to views
Arguments can be passed to a view like so:

```php
Route::get('/hello/{name}',function($name){
    return view('hello',compact('name'));
});
```

- Arguments are _transfered_ to a view using the `compact()` function. 
- The `compact()` takes a variable number of parameters. 
	- Each parameter can be either a string containing the name of the variable, or an array of variable names.
- The arrays can be nested, `compact()` handles them recursively.
- `compact()` returns an array with all the variables in it.

# Controllers
Controllers are a bit like the bandleader, it controll who interacts with the __Model__ to create data for the __View__.

## Setup
We can controllers using the command:

```
php artisan make:controller <nameController> --resource
```

- By convention the name of a controller starts with a capital letter followed by _Controller_, in one word.
- The `--resource` flag is used to initiate default methods when the controller is created.

# Referencing route to a controller

Lets take for example this route:

```php
use App\Http\Controllers\ArticleController;

Route::get('/articles',[AuthController::class,'index']);
```

- `/articles` is the name of the route
- `[AuthController::class, index]`, is the route which references the `AuthController` and assigns the index method.

# Migrations

>In the root of our directory there is a `.env` file where we can add details that we want to keep hidden, such as database credentials. Aftre altering the `.env` file we must reinitialize our app with the following command `php artisan config:clear`

- Migrations are a way to alter and update a database in a structured way instead of using something like _phpmyadmin_.
- To creat a migration we can use the artisan command:

```bash
php artisan make:migration create_articles_table
```

- Migrations can be found at `database -> migrations`.
- In a migration file there two methods `up()` and `down()`:
	- `up()` is for running the migration
	- `down()` is for reversing the migration

## The `up()` method
We can create fields in a given table, by using the `$table` object and making a call to a specific method.

```php
  public function up()
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->text('content');
            $table->timestamps();
        });
    }
```

# Creating models
We can create a model for a given migration by using the following command: `php artisan make:model Article`

# Blade templates
- Blade is a simple and yet powerfull templating engine driven by view template inheritance and sections. 
- If blade doesn't provide a control structure we might need, we can simply use plain PHP inside our Blade template.

## Echoing data
```
@php $name = "John"; @endphp
<p>{{ $name }}</p>
```

## Blade loops

```
@for($i = 0; $i < 10; $i++)
    <p>The current value is {{ $i }}</p>
@endfor
```

```
@foreach($posts as $post)
    <p><{{ $post->title }}/p>
@endforeach
```

```
@while(true)
    <p>Hi, I am a loop</p>
@endwhie
```

## Defining a master layout
Most web application follow the same layout, to avoid repetition we can create a master page which will be called every time a page will be created.

Folder structure example:
```
|-resources
    |-views
        |-posts
          index.blade.php   
        |-layout
          app.blade.php
```

```html
<!-- resources/views/layout/app.blade.php -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@yield('title')</title>
</head>
<body>
    
    @yield('content')

</body>
</html>
```

In every page we create, we include the master layout
```
@extends('layout.app')

@section('title','My first page')

@section('content')
    <p>lorem ipsum...</p> 
@endsection
```

# Components
- Components and slots provide similar benefits to sections, components and includes
- There are two ways to write components
	- Classe based components
	- Anonymous components
- Class based components can be created using the `make:component` artisan command. For example if we wanted to create a simple `Alert` component, we could use the following command:

```shell
php artisan make:component Alert
```

- `make:component` will place the component in the `app/View/Components` directory.
- When a component is created, a corresponding view template will be created. The view is placed in the `resources/views/components` directory.
- Components can also be created within subdirectories:

```shell
php artisan make:component Forms/Input
```

>The snippet above creates an `Input` component in the `app/View/Components/Forms` directory and its corresponding view will be placed in the `resources/views/components/forms` directory.

## Rendering components
- A component can be displayed by using a Blade component tag within one of our Blade templates.
- A Blade component tag stars with `x-` followed by the kebab case name of the component class.

```
<x-alert/>
 
<x-user-profile/>
```

- To indicate directory nesting we can use the `.` character. For a component located at `app/View/Components/Inputs/Button.php`, we can reder it like so: `<x-inputs.button/>`

## Passing Data To Components
- Data can be passed using HTML attributes
- Hard-coded primitive values may be passed using HTML attribute strings
- PHP expressions and variables should be passed via attributes that use `:` character as prefix

```
<x-alert type="error" :message="$message"/>
```

- The data required by components should be defined in their class constructor
- Public properties of a component will automatically be available to the component's view
- It's unnecessary to pass data to the view from the componenet's `render` method

```php
<?php
 
namespace App\View\Components;
 
use Illuminate\View\Component;
 
class Alert extends Component
{
    /**
     * The alert type.
     * @var string
     */
    public $type;
 
    /**
     * The alert message.
     * @var string
     */
    public $message;
 
    /**
     * Create the component instance.
     *
     * @param  string  $type
     * @param  string  $message
     * @return void
     */
    public function __construct($type, $message)
    {
        $this->type = $type;
        $this->message = $message;
    }
 
    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View|\Closure|string
     */
    public function render()
    {
        return view('components.alert');
    }
}
```

- when the component is rendered, we can display the contents of its public variables by echoing the variables by name:

```
<div class="alert alert-{{ $type }}">
    {{ $message }}
</div>
```

## Casing
- Component constructor arguments should written using _camelCase_
- When referencing the argument names in the HTML attributes, _kebab-case_ should be used.
```php
/**
 * Create the component instance.
 *
 * @param  string  $alertType
 * @return void
 */
public function __construct($alertType)
{
    $this->alertType = $alertType;
}
```
```
<x-alert alert-type="danger" />
```
